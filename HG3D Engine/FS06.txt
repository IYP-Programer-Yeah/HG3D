#version 450

#define MaxLineLength 8

out vec3 Output1;

uniform isampler2D GBufferNormalMap;
uniform usampler2D GBufferMatID;
uniform sampler2D GBufferDepthMap;
uniform sampler2D Texture;

struct CameraData
{
	mat4 ViewMatrix;//modelview matrix
	mat4 ProjectionMatrix;//projection
	vec4 veiwport_dimensions;

	float Left, Right, Buttom, Top, Near, Far;//projection property
	vec3 Position;
	float data[19];
};
layout (std140) uniform camera
{
		CameraData CurrentCamera;
};

ivec4 GPBD(sampler2D Edge, vec2 Coordinates, vec2 DX, vec2 DY)
{
	ivec4 ret=ivec4(0);
	vec3 borderies[2];
	borderies[0]=texture(Texture,Coordinates-DX*0.25).xyz;
	borderies[1]=texture(Texture,Coordinates-DY*0.25).xyz;
	if (borderies[0].x>0.9f)
		ret+=ivec4(0,1,0,1);
	else if (borderies[0].x>0.5f)
		ret+=ivec4(0,1,0,0);
	else if (borderies[0].x>0.1f)
		ret+=ivec4(0,0,0,1);

	if (borderies[1].y>0.9f)
		ret+=ivec4(1,0,1,0);
	else if (borderies[1].y>0.5f)
		ret+=ivec4(1,0,0,0);
	else if (borderies[1].y>0.1f)
		ret+=ivec4(0,0,1,0);
	return ret;
}

ivec3 FCE(ivec4 direction, ivec2 Sides, vec2 Coordinates, vec2 DX, vec2 DY, sampler2D texture)
{
	const vec2 EdgeMask=(direction.x+direction.z)!=0?vec2(0,1):vec2(1,0);
	const vec2 SideMask=(direction.x+direction.z)!=0?vec2(1,0):vec2(1,0);
	
	const vec2 Step=((direction.x+direction.z)!=0?DY:DX)*((direction.x+direction.y)!=0?1.0f:-1.0f);
	const vec2 OrthoStep=(direction.x+direction.z)!=0?DX:DY;
	
	vec2 CurrentPose=(direction.x+direction.y)!=0?Coordinates:Coordinates+Step;
	
	ive3 ret=ivec3(0);
	bool FSR=(Sides.x!=1);
	bool SSR=(Sides.y!=1);

	int StepCount=1;

	vec2 Center,FS,SS;

	while(!FSR&&!SSR)
	{
		Center=texture(Texture,CurrentPos).xy;
		if (dot(Center*EdgeMask,vec2(1))==1)
		{
			ret.y=1;
			retrun ret;
		}
		if (!FSR)
		{
			ret.x++;
			FS=texture(Texture,CurrentPos-OrthoStep).xyz;
			if (dot(FS*EdgeMask,vec2(1))==1)
			{
				ret.x=StepCount
				FSR=true;
			}
			if (dot(FS*SideMask,vec2(1))==1)
			{
				ret.x=StepCount+MaxLineLength;
				FSR=true;
			}
		}
		if (!SSR)
		{
			ret.x++;
			SS=texture(Texture,CurrentPos+OrthoStep).xy;
			if (dot(SS*EdgeMask,vec2(1))==1)
			{
				ret.z=StepCount;
				SSR=true;
			}
			if (dot(Center*SideMask,vec2(1))==0)
			{
				ret.z=StepCount+MaxLineLength;
				SSR=true;
			}
		}
		}
		if (MaxLineLength==StepCount)
			return;
		StepCount++;
		CurrentPos+=Step;
	}
		
	return ret;
}

void main()
{
	const vec2 DX=vec2(1.0f,0.0f)/CurrentCamera.veiwport_dimensions.z;
	const vec2 DY=vec2(0.0f,1.0f)/CurrentCamera.veiwport_dimensions.w;
	const vec2 FragCoord=round((gl_FragCoord.xy/CurrentCamera.veiwport_dimensions.zw/16+0.6)*CurrentCamera.veiwport_dimensions.zw)/CurrentCamera.veiwport_dimensions.zw+0.5*(DX+DY);
	
	ivec4 CurrentPoint=GPBD(Texture,FragCoord,DX,DY);

	vec3 colors[5];
	colors[0]=texture(GBufferDepthMap,FragCoord).xyz;
	Output1=colors[0];
	if (dot(CurrentPoint,CurrentPoint)==0)
		return;
	/*
	Output1=texture(Texture,FragCoord).xyz;
	return;
	*/
	colors[1]=texture(GBufferDepthMap,FragCoord-DX).xyz;
	colors[2]=texture(GBufferDepthMap,FragCoord+DX).xyz;
	colors[3]=texture(GBufferDepthMap,FragCoord-DY).xyz;
	colors[4]=texture(GBufferDepthMap,FragCoord+DY).xyz;

	if (dot(CurrentPoint,CurrentPoint)==4)
	{
		Output1=(colors[0]*4.0f+colors[1]+colors[2]+colors[3]+colors[4])/8.0f;
		return;
	}
	else if (dot(CurrentPoint,CurrentPoint)==3)
	{
		ivec3 end;

		ivec4 direction;
		ivec2 Sides;

		if (dot(CurrentPoint,ivec4(1,0,1,0))==2)
		{
			if (CurrentPoint.y==1)
				direction=ivec4(0,0,1,0);
			else
				direction=ivec4(1,0,0,0);
			Sides(0,1,0,1);
		}
		else
		{
			if (CurrentPoint.x==1)
				direction=ivec4(0,0,0,1);
			else
				direction=ivec4(0,1,0,0);
			Sides(1,0,1,0);
		}

		end=FCE(direction, Sides, FragCoords, DX, DY, Texture);
		if (dot(End,ivec3(1,0,1))==0)
			return;
		vec2 Portions;
		if (End.x>MaxLineLength)
			Portions.x=0.5-0.25/float(End.x-MaxLineLength);
		else if (End.x>0)
		{
			if (End.x==1)
				Portions.x=0.125;
			else
				Portions.x=(0.5f+0.5f*(float(End.x)*0.5f-1.0f)/(float(End.x)*0.5f)*0.25f;
		}
		return;
	}
	else if (dot(CurrentPoint,CurrentPoint)==2)
	{
		
		
		return;
	}
	else if (dot(CurrentPoint,CurrentPoint)==1)
	{
		//Output1=vec3(1,0,0);
		return;
	}

}