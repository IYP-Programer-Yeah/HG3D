#version 330
in vec3 normal;
in vec3 position;
in vec2 coord;

out vec4 Output1;

//layout(early_fragment_tests) in; //will try this later

uniform int Lights_Nums;
uniform sampler2D SMTex_Sampler[8];
uniform mat4 light_proj_view_matrix[8];

struct light
{
	vec3 light_position;//light pos

	float max_radius;//the maximum radius of light contribution

	vec3 light_color;//light color

	float cut_off_cos;//cosine of the the the cut of angle 

	vec3 Attenuation;//attenuation values

	float nonesense2;

	vec3 direction;//the direction of light

	int nonesense1;
		
};

layout (std140) uniform lights
{
		light Light[32];
};

layout (std140) uniform TSOS
{
		vec2 text_offsets[32];
};


#define PCF
#ifdef PCF
#define delta_intesity        0.1111
#endif

void main() 
{
	vec3 final_color;
	final_color=vec3(0,0,0);
	vec3 Normal=normalize(normal);
	light currentlightl;
	/*vec2 text_offsets[8];
	text_offsets[0]=vec2(0.00025,0.0);text_offsets[1]=vec2(-0.00025,0.0);text_offsets[2]=vec2(0.0,0.00025);text_offsets[3]=vec2(0.0,-0.00025);
	text_offsets[4]=vec2(0.00017,0.00017);text_offsets[5]=vec2(-0.00017,0.00017);text_offsets[6]=vec2(-0.00017,-0.00017);text_offsets[7]=vec2(0.00017,-0.00017);*/
	for (int i=0;i<Lights_Nums;i++)
	{
		currentlightl=Light[i];
		vec3 Light_To_Point=position-currentlightl.light_position;
		float LTP_Length=length(Light_To_Point);
		Light_To_Point=Light_To_Point/LTP_Length;
		if (LTP_Length<currentlightl.max_radius)
		{	
			float LTP_N_Dot=dot(Light_To_Point,Normal);
			if (LTP_N_Dot<=0.0)
			{
				float Cut_Off_Dot;
				if (currentlightl.cut_off_cos==-1.0)
					Cut_Off_Dot=-1;
				else
					Cut_Off_Dot=currentlightl.cut_off_cos-dot(Light_To_Point,currentlightl.direction);
				if (Cut_Off_Dot<0.01)
				{
					float Cut_Off_Effect=min(1.0,(0.01-Cut_Off_Dot)*100.0);
					if (i>7)
					{
						float Attenuation=currentlightl.Attenuation[0]+LTP_Length*(currentlightl.Attenuation[1]+LTP_Length*currentlightl.Attenuation[2]);
						final_color-=currentlightl.light_color*(LTP_N_Dot/Attenuation);
					}
					else if (currentlightl.nonesense1>16777215||currentlightl.nonesense1<0)
					{

						vec4 Actual_Pos=light_proj_view_matrix[i]*vec4(position,1);
						vec3 SMCoords=(Actual_Pos.xyz/Actual_Pos.w+1)/2;
						if (SMCoords.x<0.001||SMCoords.x>0.999||SMCoords.y<0.001||SMCoords.y>0.999||SMCoords.z<0.001||SMCoords.z>1.0)
						{
							float Attenuation=currentlightl.Attenuation[0]+LTP_Length*(currentlightl.Attenuation[1]+LTP_Length*currentlightl.Attenuation[2]);
							final_color-=currentlightl.light_color*(LTP_N_Dot/Attenuation);
						}
						else 
						{
#ifndef PCF
							////////////////////////////VSM///////////////////////////////////////
							

							/*float off_set=0.1/currentlightl.max_radius;
							float depth=SMCoords.z-off_set;
							vec2 texture_data=textureLod(SMTex_Sampler[i],SMCoords.xy, 1).xy;
							float Attenuation=currentlightl.Attenuation[0]+LTP_Length*(currentlightl.Attenuation[1]+LTP_Length*currentlightl.Attenuation[2]);
							float draw_val=1;
							if (depth>texture_data.x)
							{
								float variance=texture_data.y-texture_data.x*texture_data.x;
								float mD = texture_data.x - SMCoords.z; 
								float mD_2 = mD * mD;
								draw_val*=min(1,max(0,variance/(variance+mD_2)));
							}
							final_color-=currentlightl.light_color*(LTP_N_Dot/Attenuation)*draw_val;
							*/


							


							float off_set=0.1/(currentlightl.max_radius-1.0);
							float filter_offset=off_set*2;
							float depth=SMCoords.z-off_set;
							vec2 texture_data=texelFetch(SMTex_Sampler[i],ivec2(floor(SMCoords.xy*textureSize(SMTex_Sampler[i],0) ) ) , 0).xy;
							float Attenuation=currentlightl.Attenuation[0]+LTP_Length*(currentlightl.Attenuation[1]+LTP_Length*currentlightl.Attenuation[2]);
							if (depth<=texture_data.x)
							{
								float draw_val=1.0;
								vec2 tempSMcoords;
								for (int j=0;j<8;j++)
								{
									tempSMcoords=SMCoords.xy+text_offsets[j];
									if (!(tempSMcoords.x<0.001||tempSMcoords.x>0.999||tempSMcoords.y<0.001||tempSMcoords.y>0.999))
									{
										texture_data=textureLod(SMTex_Sampler[i],tempSMcoords,1).xy;
										if (SMCoords.z>texture_data.x+filter_offset)	
										{				
											float variance=texture_data.y-texture_data.x*texture_data.x;
											float mD = texture_data.x - SMCoords.z; 
											float mD_2 = mD * mD;
											draw_val*=min(1,max(0,variance/(variance+mD_2)));
										}
									}						
								}
								final_color-=currentlightl.light_color*(LTP_N_Dot/Attenuation)*draw_val;
							}
#else
							/////////////////////////////////////PCF//////////////////////////////
							
							float off_set=0.1/(currentlightl.max_radius-1.0);
							float filter_offset=off_set*2;
							float depth=SMCoords.z-off_set;
							vec2 texture_data=texture(SMTex_Sampler[i],SMCoords.xy).xy;
							float Attenuation=currentlightl.Attenuation[0]+LTP_Length*(currentlightl.Attenuation[1]+LTP_Length*currentlightl.Attenuation[2]);
							float draw_val=1;
							vec2 tempSMcoords;
							if (depth>texture_data.x)
								draw_val-=delta_intesity;
							for (int j=0;j<8;j++)
							{
								tempSMcoords=SMCoords.xy+text_offsets[j];
								if (!(tempSMcoords.x<0.001||tempSMcoords.x>0.999||tempSMcoords.y<0.001||tempSMcoords.y>0.999))
								{
									texture_data=texture(SMTex_Sampler[i],tempSMcoords).xy;
									if (SMCoords.z>texture_data.x+filter_offset)	
										draw_val-=delta_intesity;
								}
							}
							final_color-=currentlightl.light_color*(LTP_N_Dot/Attenuation)*draw_val;
							
#endif
						}
					}
					else
					{
						float Attenuation=currentlightl.Attenuation[0]+LTP_Length*(currentlightl.Attenuation[1]+LTP_Length*currentlightl.Attenuation[2]);
						final_color-=currentlightl.light_color*(LTP_N_Dot/Attenuation);
					}
					final_color*=Cut_Off_Effect;
				}
			}
		}
	}
	Output1=vec4(final_color,1);
} 